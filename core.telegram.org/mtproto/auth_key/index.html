
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
            <title>﻿Creating an Authorization Key</title>
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <meta property="description" content="The query format is described using Binary Data Serialization and the TL Language. All large numbers are transmitted as…">
                    <meta property="og:title" content="﻿Creating an Authorization Key">
                        <meta property="og:image" content="">
                            <meta property="og:description" content="The query format is described using Binary Data Serialization and the TL Language. All large numbers are transmitted as…">
                                <link rel="shortcut icon" href="/favicon.ico?3" type="image/x-icon" />
                                
                                <link href="/css/bootstrap.min.css?3" rel="stylesheet">
                                    
                                    <link href="/css/telegram.css?178" rel="stylesheet" media="screen">
                                        <style>
                                            </style>
                                        </head>
    <body>
        <div class="dev_page_wrap">
            <div class="dev_page_head navbar navbar-static-top navbar-tg">
                <div class="navbar-inner">
                    <div class="container clearfix">
                        <ul class="nav navbar-nav navbar-right hidden-xs"><li class="navbar-twitter"><a href="https://twitter.com/telegram" target="_blank" data-track="Follow/Twitter" onclick="trackDlClick(this, event)"><i class="icon icon-twitter"></i><span> Twitter</span></a></li></ul>
                        <ul class="nav navbar-nav">
                            <li><a href="//telegram.org/">Home</a></li>
                            <li class="hidden-xs"><a href="//telegram.org/faq">FAQ</a></li>
                            <li class="hidden-xs"><a href="//telegram.org/apps">Apps</a></li>
                            <li class=""><a href="/api">API</a></li>
                            <li class="active"><a href="/mtproto">Protocol</a></li>
                            <li class=""><a href="/schema">Schema</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="container clearfix">
                <div class="dev_page">
                    <div id="dev_page_content_wrap" class=" ">
                        <div class="dev_page_bread_crumbs"><ul class="breadcrumb clearfix"><li><a  href="/mtproto" >Mobile Protocol</a></li><i class="icon icon-breadcrumb-divider"></i><li><a  href="/mtproto/auth_key" >﻿Creating an Authorization Key</a></li></ul></div>
                        <h1 id="dev_page_title" dir="auto">﻿创建授权密钥Creating an Authorization Key</h1>
                        
                        <div id="dev_page_content" dir="auto"><p>查询格式由 <a href="/mtproto/serialize">Binary Data Serialization</a> 和 <a href="/mtproto/TL">TL Language</a> 进行描述。所有大数字都以字符串形式传输，大字节序排列。哈希函数例如SHA1，返回字符串（20字节），也可以被解释为大字节序数字。小数字（<code>int</code>，<code>long</code>，<code>int128</code>，<code>int256</code>）通常是小字节序；但是，如果他们是SHA1的一部分，则不会重新排列字节。这样，如果<code> long x </code>是字符串<code>s</code>的SHA1的低64位，则取<code>SHA1(s)</code>20位字符串的<em>最后</em>8字节，将其直接解释成64位整数。</p>
                            <p>在发送未加密的消息（在这种情况下要求生成授权密钥）之前，客户端必须进行如下的（p，q）授权。</p>
                            <h4><a class="anchor" name="dh-exchange-initiation" href="#dh-exchange-initiation"><i class="anchor-icon"></i></a>准备DH交换DH exchange initiation</h4>
                            <p>1) 客户端发送req_pq_multi</p>
                            <pre><code>req_pq_multi#be7e8ef1 nonce:int128 = ResPQ;</code></pre>
                            <p>or (deprecated)</p>
                            <pre><code>req_pq#60469778 nonce:int128 = ResPQ;</code></pre>
                            <p><em>nonce</em>是客户端生成的随机数，并在此后的通讯中标识客户端。服务器会透传回nonce值。</p>
                            <p>2) 服务器响应resPQ</p>
                            <pre><code>resPQ#05162463 nonce:int128 server_nonce:int128 pq:string server_public_key_fingerprints:Vector long = ResPQ;</code></pre>
                            <p>字符串pq是个二进制大端格式编码的自然数。 该数字是两个不同的质数的乘积。 通常pq小于等于2 ^ 63-1。 <em>server_nonce</em>是服务器随机数。</p>
                            <p><code>server_public_key_fingerprints</code>是RSA公钥指纹列表（SHA1的64个低位 (server_public_key); 公钥被表示为裸类型<code>rsa_public_key n:string e:string = RSAPublicKey</code>, 通常，n和е是大字节序格式的数字，序列化为字节串，然后计算SHA1）。为兼容老版本客户端，废弃的<code>req_pq</code>查询只返回一个公钥指纹；<code>req_pq_multi</code>查询会返回多个公钥指纹。</p>
                            <p>客户端打包时会预埋一些RSA公钥，客户端通过收到的server_public_key_fingerprints选择预埋的公钥进行后续流程。</p>
                            <p>后续所有消息的纯文本和加密部分都包含（nonce，server_nonce），这样可以标识一个“临时会话”，本文说的密钥协议的一次运行使用相同的（nonce，server_nonce）对。入侵者无法与服务器使用相同参数创建一个并行会话，因为服务器会用一个不同的server_nonce创建“临时会话”。</p>
                            <p>一次运行指的是从开始创建auth_key到auth_key创建结束，可以这么理解，一旦开始创建，要么成功要么失败，一旦失败又需要重新发起。</p>
                            <p>这一步也是明文交换</p>
                            <h4><a class="anchor" name="proof-of-work" href="#proof-of-work"><i class="anchor-icon"></i></a>工作量证明Proof of work</h4>
                            <p>3) 客户端将pq分解为素数因子，使得p &lt; q。</p>
                            <p>这将启动一轮Diffie-Hellman密钥交换。</p>
                            <h4><a class="anchor" name="presenting-proof-of-work-server-authentication" href="#presenting-proof-of-work-server-authentication"><i class="anchor-icon"></i></a>出示工作量证明；服务器认证Presenting proof of work; Server authentication</h4>
                            <p>4) 客户端发送查询req_DH_params</p>
                            <pre><code>req_DH_params#d712e4be nonce:int128 server_nonce:int128 p:string q:string public_key_fingerprint:long encrypted_data:string = Server_DH_Params</code></pre>
                            <p>encrypted_data获得方式如下：</p>
                            <ul>
                                <li>new_nonce := 客户端生成新的随机数</li>
                                <li><p>data := 序列化的 </p>
                                    <pre><code>p_q_inner_data#83c95aec pq:string p:string q:string nonce:int128 server_nonce:int128 new_nonce:int256 = P_Q_inner_data</code></pre>
                                    <p>或者</p>
                                    <pre><code>p_q_inner_data_temp#3c6a84d4 pq:string p:string q:string nonce:int128 server_nonce:int128 new_nonce:int256 expires_in:int = P_Q_inner_data;</code></pre>
                                </li>
                            </ul>
                            <ul>
                                <li>data_with_hash := SHA1(data) + data + (any random bytes); 随机字节填充使得长度等于255字节。</li>
                                <li>encrypted_data := RSA (data_with_hash, server_public_key); a 255-byte long number (big endian) is raised to the requisite power over the requisite modulus, and the result is stored as a 256-byte number.</li>
                            </ul>
                            <p>Someone might intercept the query and replace it with their own, independently decomposing pq into factors instead of the client. The only field that it makes sense to modify is new_nonce which would be the one an intruder would have to re-generate (because an intruder cannot decrypt the encrypted data sent by the client). Since all subsequent messages are encrypted using new_nonce or contain new_nonce_hash, they will not be processed by the client (an intruder would not be able to make it look as though they had been generated by the server because they would not contain new_nonce). Therefore, this intercept will only result in the intruder’s completing the authorization key generation protocol in place of the client and creating a new key (that has nothing to do with the client); however, the same effect could be achieved simply by creating a new key in one&#39;s own name.</p>
                            <p>An alternative form of inner data (<code>p_q_inner_data_temp</code>) is used to create temporary keys, that are only stored in the server RAM and are discarded after at most <code>expires_in</code> seconds. The server is free to discard its copy earlier. In all other respects the temporary key generation protocol is the same. After a temporary key is created, the client usually binds it to its principal authorisation key by means of the <a href="/method/auth.bindTempAuthKey">auth.bindTempAuthKey</a> method, and uses it for all client-server communication until it expires; then a new temporary key is generated. Thus Perfect Forward Secrecy (PFS) in client-server communication is achieved. <a href="/api/pfs">Read more about PFS »</a></p>
                            <p>5) 服务器以两种方式之一响应：</p>
                            <pre><code>server_DH_params_fail#79cb045d nonce:int128 server_nonce:int128 new_nonce_hash:int128 = Server_DH_Params;
server_DH_params_ok#d0e8075c nonce:int128 server_nonce:int128 encrypted_answer:string = Server_DH_Params;</code></pre>
                            <p>encrypted_answer获取方式如下：</p>
                            <ul>
                                <li>new_nonce_hash := SHA1（new_nonce）的低128位；</li>
                                <li><p>answer := 序列化的 </p>
                                    <pre><code>server_DH_inner_data#b5890dba nonce:int128 server_nonce:int128 g:int dh_prime:string g_a:string server_time:int = Server_DH_inner_data;</code></pre>
                                </li>
                                <li><p>answer_with_hash := SHA1(answer) + answer +（0-15个随机字节）； 使字节长度可以被16整除;</p>
                                </li>
                                <li>tmp_aes_key := SHA1(new_nonce + server_nonce) + substr (SHA1(server_nonce + new_nonce), 0, 12);</li>
                                <li>tmp_aes_iv := substr (SHA1(server_nonce + new_nonce), 12, 8) + SHA1(new_nonce + new_nonce) + substr (new_nonce, 0, 4);</li>
                                <li>encrypted_answer := AES256_ige_encrypt (answer_with_hash, tmp_aes_key, tmp_aes_iv); 这里，tmp_aes_key是一个256位的密钥，而tmp_aes_iv是一个256位的初始化向量。与所有使用AES加密的其他实例一样，加密数据在加密之前被随机字节填充为16之前可被整除的长度。</li>
                            </ul>
                            <p>这一步之后，new_nonce仍然仅仅只有客户端和服务端可见。客户端可以确信是合法的服务端，并且响应是专门为响应客户端查询req_DH_params而生成的，因为响应数据是使用new_nonce加密的。</p>
                            <p>客户端要检查<strong>p = dh_prime</strong>是否是个安全的2048位素数（意思是<strong>p</strong>和<strong>(p-1)/2</strong>都是素数，并且2^2047 &lt; p &lt; 2^2048），并且<strong>g</strong>生成<strong>(p-1)/2</strong>的循环子群，即二次余数<strong>mod p</strong>。因为<strong>g</strong>总是等于2, 3, 4, 5, 6或7，这很容易用二次互易定律完成，在<strong>p mod 4g</strong>上产生一个简单的条件 — 也就是说：</p>
                            <p>对于<strong>g = 2</strong>，<strong>p mod 8 = 7</strong>；</p>
                            <p>对于<strong>g = 3</strong>，<strong>p mod 3 = 2</strong>；</p>
                            <p><strong>g = 4</strong>没有额外的条件；</p>
                            <p>对于<strong>g = 5</strong>，<strong>p mod 5 = 1 或 4</strong>；</p>
                            <p>对于<strong>g = 6</strong>，<strong>p mod 24 = 19 或 23</strong>；</p>
                            <p>对于<strong>g = 7</strong>，<strong>p mod 7 = 3, 5 或 6</strong>；</p>
                            <p>客户端检查了<strong>g</strong> 和 <strong>p</strong>之后，可以缓存结果，这样就不用重复计算。</p>
                            <p>如果验证花费的时间太长（对于较旧的移动设备），可能最初只运行15次Miller-Rabin迭代来验证<strong>p</strong>和<strong>(p - 1)/2</strong>是素数，错误概率不超过十亿分之一，稍后在后台做更多的迭代。</p>
                            <p>另一个优化是，客户端代码里嵌入一些已知的好用的<strong>(g,p)</strong>对（或者仅嵌入已知的安全素数<strong>p</strong>，因为<strong>g</strong>执行期容易验证），以避免在运行时进行这样的验证。 服务器很少更改这些值，因此通常将服务器的<strong>dh_prime</strong>当前值放置在表中。例如，<strong>dh_prime</strong>的当前值等于（大端字节序）</p>
                            <pre><code>C7 1C AE B9 C6 B1 C9 04 8E 6C 52 2F 70 F1 3F 73 98 0D 40 23 8E 3E 21 C1 49 34 D0 37 56 3D 93 0F
48 19 8A 0A A7 C1 40 58 22 94 93 D2 25 30 F4 DB FA 33 6F 6E 0A C9 25 13 95 43 AE D4 4C CE 7C 37
20 FD 51 F6 94 58 70 5A C6 8C D4 FE 6B 6B 13 AB DC 97 46 51 29 69 32 84 54 F1 8F AF 8C 59 5F 64
24 77 FE 96 BB 2A 94 1D 5B CD 1D 4A C8 CC 49 88 07 08 FA 9B 37 8E 3C 4F 3A 90 60 BE E6 7C F9 A4
A4 A6 95 81 10 51 90 7E 16 27 53 B5 6B 0F 6B 41 0D BA 74 D8 A8 4B 2A 14 B3 14 4E 0E F1 28 47 54
FD 17 ED 95 0D 59 65 B4 B9 DD 46 58 2D B1 17 8D 16 9C 6B C4 65 B0 D6 FF 9C A3 92 8F EF 5B 9A E4
E4 18 FC 15 E8 3E BE A0 F8 7F A9 FF 5E ED 70 05 0D ED 28 49 F4 7B F9 59 D9 56 85 0C E9 29 85 1F
0D 81 15 F6 35 B1 05 EE 2E 4E 15 D0 4B 24 54 BF 6F 4F AD F0 34 B1 04 03 11 9C D8 E3 B9 2F CC 5B</code></pre>
                            <p>6) 客户端生成一个2048位的随机数<em>b</em>，并向服务器发送</p>
                            <pre><code>set_client_DH_params#f5045f1f nonce:int128 server_nonce:int128 encrypted_data:string = Set_client_DH_params_answer;</code></pre>
                            <p>encrypted_data获取方式如下：</p>
                            <ul>
                                <li>g_b := pow(g, b) mod dh_prime;</li>
                                <li><p>data := 序列化的 </p>
                                    <pre><code>client_DH_inner_data#6643b654 nonce:int128 server_nonce:int128 retry_id:long g_b:string = Client_DH_Inner_Data</code></pre>
                                </li>
                                <li><p>data_with_hash := SHA1(data) + data + (0-15随机填充字节)；16字节对齐；</p>
                                </li>
                                <li>encrypted_data := AES256_ige_encrypt (data_with_hash, tmp_aes_key, tmp_aes_iv);</li>
                            </ul>
                            <p>retry_id第一次尝试时等于0；否则，它等于上次尝试失败时的auth_key_aux_hash (参阅第9项)。</p>
                            <p>7) 此后，auth_key等于<code>pow(g, {ab}) mod dh_prime</code>；服务器由<code>pow(g_b, a) mod dh_prime</code>计算出结果，客户端由<code>(g_a)^b mod dh_prime</code>计算出结果。</p>
                            <p>8) auth_key_hash是SHA1 (auth_key)的低64位。服务器检查是否已经存在相同的auth_key_hash，并以下列方式之一进行响应。</p>
                            <h4><a class="anchor" name="dh-key-exchange-complete" href="#dh-key-exchange-complete"><i class="anchor-icon"></i></a>DH密钥交换完成 DH key exchange complete</h4>
                            <p>9) 服务器响应的3种方式：</p>
                            <pre><code>dh_gen_ok#3bcbf734 nonce:int128 server_nonce:int128 new_nonce_hash1:int128 = Set_client_DH_params_answer;
dh_gen_retry#46dc1fb9 nonce:int128 server_nonce:int128 new_nonce_hash2:int128 = Set_client_DH_params_answer;
dh_gen_fail#a69dae02 nonce:int128 server_nonce:int128 new_nonce_hash3:int128 = Set_client_DH_params_answer;</code></pre>
                            <ul>
                                <li>new_nonce_hash1, new_nonce_hash2, 和 new_nonce_hash3 是从new_nonce派生出来的3个字符串的SHA1的低128位，派生方法是new_nonce添加1，2或3这单个字节，随后添加auth_key_aux_hash的8个字节。不同的值来防止入侵者将服务器响应由dh_gen_ok修改为dh_gen_retry。</li>
                                <li>auth_key_aux_hash是SHA1(auth_key)的64个高位。不能与auth_key_hash混淆。</li>
                            </ul>
                            <p>另一种情况下，客户端会去步骤 6) 重新生成新的 <em>b</em>.<br>在第一种情况下，客户端和服务器已经协商好了auth_key，接下来就放弃所有临时数据，客户端使用auth_key创建另一个加密会话。同时server_salt 初始设置为<code>substr(new_nonce, 0, 8) XOR substr(server_nonce, 0, 8)</code>。需要的话，客户端存储第5步收到的server_time与本机时间差，用作客户端时间矫正和生成msg_id。</p>
                            <p><strong>重要</strong>：除了 Diffie-Hellman 素数 <strong>dh_prime</strong> 和 <strong>g</strong> 生成器的条件外，双方都应检查 <strong>g</strong>，<strong>g_a</strong> 和 <strong>g_b</strong> 大于 <strong>1</strong> 并且小于 <strong>dh_prime - 1</strong>。我们建议检查 <strong>g_a</strong> 和 <strong>g_b</strong> 介于 <strong>2^{2048-64}</strong> 和 <strong>dh_prime - 2^{2048-64}</strong> 之间。</p>
                            <h4><a class="anchor" name="error-handling-lost-queries-and-responses" href="#error-handling-lost-queries-and-responses"><i class="anchor-icon"></i></a>错误处理 Error Handling (Lost Queries and Responses)</h4>
                            <p>如果客户端在一定的时间内没有收到服务器的响应，则可以重新发送查询。 如果服务器已经响应了这个查询（完全相同的请求，不是相似：重发请求的所有参数必须相同），但是没有到达客户端，服务器只需重新发送相同的响应。服务器会记录第 1) 步中的响应最多10分钟。如果服务器忘记了响应或必要的临时数据，客户端就得从头开始了。</p>
                            <p>服务器端可以认为，如果客户端用上一个服务器响应的数据做了下一步查询，则客户端已经接收了消息，服务器可以删掉缓存。</p>
                            <h4><a class="anchor" name="usage-example" href="#usage-example"><i class="anchor-icon"></i></a>用法示例 Usage Example</h4>
                            <p>生成授权密钥需要的所有接口列表示例：<a href="/mtproto/samples-auth_key">创建授权密钥用法示例</a>。</p>
                        </div>
                        
                    </div>
                    
                </div>
            </div>
            <div class="footer_wrap">
                <div class="footer_columns_wrap clearfix footer_desktop">
                    <div class="footer_column footer_column_telegram">
                        <h5>Telegram</h5>
                        <div class="footer_telegram_description"></div>
                        Telegram is a cloud-based mobile and desktop messaging app with a focus on security and speed.
                    </div>
                    
                    <div class="footer_column">
                        <h5><a href="//telegram.org/faq">About</a></h5>
                        <ul>
                            <li><a href="//telegram.org/faq">FAQ</a></li>
                            <li><a href="//telegram.org/blog">Blog</a></li>
                            <li><a href="//telegram.org/jobs">Jobs</a></li>
                        </ul>
                    </div>
                    <div class="footer_column">
                        <h5><a href="//telegram.org/apps#mobile-apps">Mobile Apps</a></h5>
                        <ul>
                            <li><a href="//telegram.org/dl/ios">iPhone/iPad</a></li>
                            <li><a href="//telegram.org/dl/android">Android</a></li>
                            <li><a href="//telegram.org/dl/wp">Windows Phone</a></li>
                        </ul>
                    </div>
                    <div class="footer_column">
                        <h5><a href="//telegram.org/apps#desktop-apps">Desktop Apps</a></h5>
                        <ul>
                            <li><a href="//desktop.telegram.org/">PC/Mac/Linux</a></li>
                            <li><a href="//macos.telegram.org/">macOS</a></li>
                            <li><a href="//telegram.org/dl/web">Web-browser</a></li>
                        </ul>
                    </div>
                    <div class="footer_column footer_column_platform">
                        <h5><a href="/">Platform</a></h5>
                        <ul>
                            <li><a href="/api">API</a></li>
                            <li><a href="//translations.telegram.org/">Translations</a></li>
                            <li><a href="//instantview.telegram.org/">Instant View</a></li>
                        </ul>
                    </div>
                </div>
                <div class="footer_columns_wrap clearfix footer_mobile">
                    <div class="footer_column">
                        <h5><a href="//telegram.org/faq">About</a></h5>
                    </div>
                    <div class="footer_column">
                        <h5><a href="//telegram.org/blog">Blog</a></h5>
                    </div>
                    <div class="footer_column">
                        <h5><a href="//telegram.org/apps">Apps</a></h5>
                    </div>
                    <div class="footer_column">
                        <h5><a href="/">Platform</a></h5>
                    </div>
                    <div class="footer_column">
                        <h5><a href="https://twitter.com/telegram" target="_blank" data-track="Follow/Twitter" onclick="trackDlClick(this, event)">Twitter</a></h5>
                    </div>
                </div>
            </div>
        </div>
        <script src="/js/main.js?27"></script>
        
        <script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                 (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                 m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                 })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
                 
                 ga('create', 'UA-45099287-4', 'auto');
                 ga('set', 'anonymizeIp', true);
                 ga('send', 'pageview');backToTopInit();
            </script>
    </body>
</html>
<!-- page generated in 10.61ms -->
